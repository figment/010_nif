//--------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File:
// Author:
// Revision:
// Purpose:
//--------------------------------------

RequiresVersion( 6.0 );


// Define the headers
LittleEndian(); 

//if( !exists( header ) ) {
//    Printf("Load NifTemplate.bt or Nif_Fallout4.bt");
//    Exit(-1);
//}

typedef unsigned char	byte;


typedef struct  {
    int unk;
    Ref boneData <comment="BSSkin::BoneData">;
    int numBones;
    Ref bones[numBones];
    int numWeights;
    if (numWeights > 0)
        Vector3 weights[numWeights];
} BSSkin_Instance <name="BSSkin::Instance">;

typedef struct {
    uint numBones;
    struct BSSkin_BoneTrans {
        Vector3 bsphere <comment="?">;
        float bsrad <comment="?">;
        Vector3 rot[3];
        Vector3 trans;
        float scale;
    } bones[numBones]<name="bones",optimize=false>;
} BSSkin_BoneData <name="BSSkin::BoneData">;

typedef struct {
    NiString root;
    NiString variableName;
    float unk;
    unsigned short unk <format=hex>;
    unsigned short unk <format=hex>;
    unsigned short unk <format=hex>;
    unsigned short unk <format=hex>;
    unsigned short unk <format=hex>;
    unsigned short unk <format=hex>;
    float unk;
    float unk;
    float unk;
    float unk;
} BSConnectPoint;

typedef struct {
    IndexString name;
    int numConnectPoints;
    if (numConnectPoints > 0)
        BSConnectPoint connectPoints[numConnectPoints]<optimize=false>;
} BSConnectPoint_Parents <name="BSConnectPoint::Parents">;

typedef struct {
    IndexString name;
    byte unk;
    int numTargets;
    if (numTargets > 0)
        NiString target[numTargets]<optimize=false>;
} BSConnectPoint_Children <name="BSConnectPoint::Children">;


typedef struct {
    int blobSize;
    char blob[blobSize] <format=hex>;
} bhkPhysicsSystem <name="bhkPhysicsSystem">;


typedef struct {
    int blobSize;
    char blob[blobSize] <format=hex>;
} bhkRagdollSystem <name="bhkRagdollSystem">;

typedef struct {
    // NiExtraData base;
    int blobSize;
    char blob[blobSize] <format=hex>;
} BSClothExtraData <name="BSClothExtraData">;

typedef struct {
    IndexString name;    
    int numValues;
    hfloat values[numValues];
} BSPositionData;

typedef struct {
    int unk;
    short unk;
    short unk;
    short unk;
    int unk;
} bhkNPCollisionObject <name="bhkNPCollisionObject">;

//////////////////////////////////////////////////
typedef struct {
    hfloat x;
    hfloat y;
    hfloat z;

    // 0 flags7 == 00000000
    // 2 flags7 == 00000000
    // 3 flags7 == 00000000
    // 4 flags7 == 00000000 or 00000010
    // 5 flags7 == 00000000 or 00000001
    // 6 flags7 == 00000100 or 00000011
    // 7 flags7 == 00000110
    // 8 flasg7 == 00000101
    // 9 flasg7 == 00000111
    //10 flags7 == 00010001

    // 0 Meshes\Actors\Vertibird\CharacterAssets\VbirdDeathExplosion.nif
    // 2 Meshes\Terrain\Commonwealth\Commonwealth.4.24.52.BTR
    // 3 Meshes\Actors\LibertyPrime\LibertyPrimeHSBodyLights.nif
    // 4 Meshes\Actors\SuperMutantBehemoth\SupterMutantBehemothSwan.nif
    // 5 Meshes\Actors\Vertibird\CharacterAssets\VbirdDeathExplosion.nif
    // 6 Meshes\Actors\Character\CharacterAssets\FaceParts\MaleEyesShade.nif
    // 7 Meshes\Actors\Character\CharacterAssets\FaceParts\MaleEyesShade.nif
    // 8 Meshes\Actors\Character\CharacterAssets\FemaleHands.nif
    // 9 Meshes\Actors\Character\CharacterAssets\Hair\Female\FemaleHair05.nif
    //10 Meshes\Actors\Character\CharacterAssets\FaceParts\MaleEyes.nif

    if (flag1 == 3 || flag1 ==6)
        ushort unk <format=hex>; // Not dot product
    else
        hfloat unk1 <comment="Possible Face Weight (or vert/uv dot product)">;

    if (flag1 == 3)
        int unk <format=hex>; // dont buy that these are vert colors yet or uvs

    if (flag1 > 4) {
        hfloat ux;
        hfloat uy;
    }
    if (flag1 > 3 && flag1 != 7) {
        char normal[4];
        char tangent[4];
    }
    if (flag1 == 6 || flag1 == 7 || flag1 == 9 || flag1 == 10) 
        byte vertColors[4] <comment="Vertex Colors?">; 
    if (flag1 > 6) {
        hfloat weighs[4];
        byte bones[4];
    }
    if (flag1 == 10) {  // MaleEyes.nif
        int unk;
    }

} VERTDATA <name="Vertices">;


typedef struct {
    NiAVObject base;
    float unknown[4];
    Ref Skin;
    Ref bsProperties[2]<comment="<NiProperty>">;
    byte flag1 <comment="Vertex Data Type">;
    byte flag2 <format=hex,comment="2">;
    byte flag3 <format=hex,comment="43h">;
    byte flag4 <format=hex, comment="0 or 50h">;
    byte flag5 <format=hex>;
    byte flag6 <format=hex,comment="B0h">;
    byte flag7 <format=hex,comment="05h">;
    byte flag8 <format=hex>;

//    local bool diff=true;
//    switch(flag1)
//    {
//        case  3: diff = (flag7 != 0x00); break;
//        case  4: diff = (flag7 != 0x02); break;
//        case  6: diff = (flag7 != 0x04); break;
//        case  7: diff = (flag7 != 0x06); break;
//        case  8: diff = (flag7 != 0x05); break;
//        case  9: diff = (flag7 != 0x07); break;
//        case 10: diff = (flag7 != 0x17); break;
//    }
//    if (diff) Printf("%-60s [%3d] flag1: %2d, flag7: %s\n", GetFileName(), block_idx, flag1, IntToBinaryStr(flag7));

    int numTris;
    ushort numVerts;
    int triVertBlockSize;
    if (triVertBlockSize > 0) {  // LibertyPrimeHeadShoot01.nif
        VERTDATA verts[numVerts];
        Triangle tris[numTris];
    }
} BSTriShape <name="BSTriShape">;

typedef struct {
    BSTriShape base <open=true>;
    int numTris;

    struct Shapes
    {
        typedef struct 
        {
            int start<comment="Start of previous subshape = start(prev) * count(prev)*3">;
            int count<comment="Count of faces?">;
            int unknown<comment="Usually -1">;
            int numSubShapes;
            typedef struct {
                int indexStart<comment="=start(Prev) + count(Prev)*3">;
                int count <comment="count*3">;
                int unknown<comment="Same for each Subshape, increases each block. Matches second block array">;
                int unknown<comment="0">;
            } Subshape; 
            if (numSubShapes > 0)
                Subshape numSubShapes[numSubShapes]<optimize=false, name="Shape">;
        } Subshapes <name="Subshape">;
        
        struct Temp2
        {
            int index;
            SkyrimHavokMaterial unk<format=hex>;
            int numUnks;
            if (numUnks > 0)
                float unk2[numUnks]<optimize=false>;
        } ;

        int size1;
        int size2;
        Subshapes shape[size1]<optimize=false, name="Subshape">;

        //// The evil check.  Basically if numStuff is non zero then the section below exists
        //local bool second_stuff_flag = false;
        //local int i;
        //for (i=0;i<size;++i)
        //    second_stuff_flag |= (unk1[i].numStuff>0);
        if (size2 > size1)
        {
            int num1 <comment="Sizes again?">;
            int num2 <comment="Sizes again?">;
            int ids[num1]<comment="Matches index in subshape">;
            Temp2 unk3[num2]<optimize=false>;
            LongString ssf;
        }
    };
    Shapes stuff;

} BSSubIndexTriShape <name="BSSubIndexTriShape">;


typedef struct {
    BSTriShape base <open=true>;
    int unk;
    int unk;
    int unk;
} BSMeshLODTriShape;

typedef struct {
    // #warning "TODO:  Finish parsing this"
    IndexString name;
    int flags1<format=hex>;
    int flags2<format=hex>;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;
    int unk;

    float unk;
    int unk;
    int unk;
//    int numData;
//    if (numData>0)
//    Ref data[numData];
} BSPackedCombinedSharedGeomDataExtra;